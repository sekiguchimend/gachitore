# ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³æ©Ÿèƒ½å®Ÿè£…ãƒ•ãƒ­ãƒ¼

## ğŸ“‹ ç›®æ¬¡

1. [ãƒ—ãƒ©ãƒ³æ¦‚è¦](#ãƒ—ãƒ©ãƒ³æ¦‚è¦)
2. [æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯](#æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯)
3. [å®Ÿè£…ãƒ•ã‚§ãƒ¼ã‚º](#å®Ÿè£…ãƒ•ã‚§ãƒ¼ã‚º)
4. [ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆ](#ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆ)
5. [ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰å®Ÿè£…](#ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰å®Ÿè£…)
6. [ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰å®Ÿè£…](#ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰å®Ÿè£…)
7. [ãƒ†ã‚¹ãƒˆæ‰‹é †](#ãƒ†ã‚¹ãƒˆæ‰‹é †)
8. [ãƒªãƒªãƒ¼ã‚¹æ‰‹é †](#ãƒªãƒªãƒ¼ã‚¹æ‰‹é †)

---

## ãƒ—ãƒ©ãƒ³æ¦‚è¦

### ç„¡æ–™ãƒ—ãƒ©ãƒ³
- âœ… åŸºæœ¬æ©Ÿèƒ½ï¼ˆãƒ¯ãƒ¼ã‚¯ã‚¢ã‚¦ãƒˆè¨˜éŒ²ã€é£Ÿäº‹è¨˜éŒ²ã€AIç›¸è«‡ï¼‰
- âœ… æ²ç¤ºæ¿é–²è¦§ãƒ»æŠ•ç¨¿
- âŒ ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã«SNS URLè¡¨ç¤ºä¸å¯
- âŒ ä»–ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®é£Ÿäº‹ãƒ¡ãƒ‹ãƒ¥ãƒ¼é–²è¦§ä¸å¯
- âŒ ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ç¢ºèªä¸å¯
- âŒ ãƒ–ãƒ­ãƒƒã‚¯æ©Ÿèƒ½ä¸å¯

### ãƒ™ãƒ¼ã‚·ãƒƒã‚¯ãƒ—ãƒ©ãƒ³ï¼ˆÂ¥1,000/æœˆï¼‰
- âœ… ç„¡æ–™ãƒ—ãƒ©ãƒ³ã®ã™ã¹ã¦
- âœ… **ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã«SNS URLãƒªãƒ³ã‚¯è¡¨ç¤º** (Instagram, X, YouTube ãªã©)
- âœ… **ä»–ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®1æ—¥ã®é£Ÿäº‹ãƒ¡ãƒ‹ãƒ¥ãƒ¼é–²è¦§**
- âŒ ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ç¢ºèªä¸å¯
- âŒ ãƒ–ãƒ­ãƒƒã‚¯æ©Ÿèƒ½ä¸å¯

### ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ãƒ—ãƒ©ãƒ³ï¼ˆÂ¥3,000/æœˆï¼‰
- âœ… ãƒ™ãƒ¼ã‚·ãƒƒã‚¯ãƒ—ãƒ©ãƒ³ã®ã™ã¹ã¦
- âœ… **ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ç¢ºèªæ©Ÿèƒ½**ï¼ˆã‚ªãƒ³ãƒ©ã‚¤ãƒ³/ã‚ªãƒ•ãƒ©ã‚¤ãƒ³è¡¨ç¤ºï¼‰
- âœ… **ãƒ–ãƒ­ãƒƒã‚¯æ©Ÿèƒ½**ï¼ˆç‰¹å®šãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰ã®é–²è¦§ã‚’ãƒ–ãƒ­ãƒƒã‚¯ï¼‰
- âœ… **ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ãƒãƒƒã‚¸è¡¨ç¤º**

---

## æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯

### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ï¼ˆFlutterï¼‰
- `in_app_purchase`: ^3.2.0 - Google Play / App Store IAP
- `flutter_riverpod`: ^2.6.1 - çŠ¶æ…‹ç®¡ç†
- `shared_preferences`: ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã®ãƒ­ãƒ¼ã‚«ãƒ«ã‚­ãƒ£ãƒƒã‚·ãƒ¥

### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ï¼ˆRust APIï¼‰
- RevenueCat ã¾ãŸã¯ Google Play Billing Library
- Supabase Functions - Webhookå‡¦ç†

### ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ï¼ˆSupabaseï¼‰
- PostgreSQL - ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ç®¡ç†ãƒ†ãƒ¼ãƒ–ãƒ«
- Row Level Security (RLS) - ãƒ—ãƒ©ãƒ³åˆ¥ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡

---

## å®Ÿè£…ãƒ•ã‚§ãƒ¼ã‚º

### Phase 1: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆã¨åŸºç›¤æ§‹ç¯‰ (2-3æ—¥)
- [ ] Supabaseã«ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆ
- [ ] RLSãƒãƒªã‚·ãƒ¼è¨­å®š
- [ ] ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã«ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³æƒ…å ±è¿½åŠ 

### Phase 2: Google Play Consoleè¨­å®š (1æ—¥)
- [ ] ã‚¢ãƒ—ãƒªå†…èª²é‡‘ã®æœ‰åŠ¹åŒ–
- [ ] ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³å•†å“ã®ä½œæˆ
- [ ] ãƒ†ã‚¹ã‚¿ãƒ¼ã‚¢ã‚«ã‚¦ãƒ³ãƒˆè¨­å®š

### Phase 3: ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰å®Ÿè£… (3-4æ—¥)
- [ ] ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³çŠ¶æ…‹æ¤œè¨¼API
- [ ] Webhookå‡¦ç†ï¼ˆè³¼å…¥ãƒ»æ›´æ–°ãƒ»ã‚­ãƒ£ãƒ³ã‚»ãƒ«ï¼‰
- [ ] ãƒ—ãƒ©ãƒ³åˆ¥æ©Ÿèƒ½åˆ¶å¾¡ãƒ­ã‚¸ãƒƒã‚¯

### Phase 4: ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰å®Ÿè£… (5-7æ—¥)
- [ ] IAPè³¼å…¥ãƒ•ãƒ­ãƒ¼å®Ÿè£…
- [ ] ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ç®¡ç†ç”»é¢
- [ ] ãƒ—ãƒ©ãƒ³åˆ¥UIè¡¨ç¤ºåˆ¶å¾¡
- [ ] å„æ©Ÿèƒ½ã®å®Ÿè£…ï¼ˆSNS URLã€é£Ÿäº‹é–²è¦§ã€ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ã€ãƒ–ãƒ­ãƒƒã‚¯ï¼‰

### Phase 5: ãƒ†ã‚¹ãƒˆã¨èª¿æ•´ (3-4æ—¥)
- [ ] ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹ãƒ†ã‚¹ãƒˆ
- [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
- [ ] å¾©å…ƒæ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ

### Phase 6: ãƒªãƒªãƒ¼ã‚¹ (1-2æ—¥)
- [ ] æœ¬ç•ªç’°å¢ƒãƒ‡ãƒ—ãƒ­ã‚¤
- [ ] ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆä½œæˆ
- [ ] ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°è¨­å®š

**åˆè¨ˆæ¨å®šæœŸé–“: 15-21æ—¥**

---

## ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆ

### 1. `user_subscriptions` ãƒ†ãƒ¼ãƒ–ãƒ«

```sql
-- ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ç®¡ç†ãƒ†ãƒ¼ãƒ–ãƒ«
CREATE TABLE user_subscriptions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    subscription_tier TEXT NOT NULL CHECK (subscription_tier IN ('free', 'basic', 'premium')),

    -- Google Play / App Storeæƒ…å ±
    platform TEXT NOT NULL CHECK (platform IN ('android', 'ios')),
    product_id TEXT NOT NULL, -- 'basic_monthly' or 'premium_monthly'
    purchase_token TEXT, -- Google Playè³¼å…¥ãƒˆãƒ¼ã‚¯ãƒ³
    transaction_id TEXT, -- App Store ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ID

    -- æœ‰åŠ¹æœŸé–“
    starts_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    expires_at TIMESTAMPTZ NOT NULL,
    auto_renewing BOOLEAN DEFAULT true,

    -- ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
    status TEXT NOT NULL CHECK (status IN ('active', 'cancelled', 'expired', 'pending')) DEFAULT 'active',

    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),

    UNIQUE(user_id) -- 1ãƒ¦ãƒ¼ã‚¶ãƒ¼1ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_user_subscriptions_user_id ON user_subscriptions(user_id);
CREATE INDEX idx_user_subscriptions_expires_at ON user_subscriptions(expires_at);
CREATE INDEX idx_user_subscriptions_status ON user_subscriptions(status);

-- RLSæœ‰åŠ¹åŒ–
ALTER TABLE user_subscriptions ENABLE ROW LEVEL SECURITY;

-- ãƒãƒªã‚·ãƒ¼: è‡ªåˆ†ã®ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³æƒ…å ±ã®ã¿é–²è¦§å¯èƒ½
CREATE POLICY "Users can view own subscription"
    ON user_subscriptions FOR SELECT
    USING (auth.uid() = user_id);

-- ãƒãƒªã‚·ãƒ¼: ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®ã¿æ›´æ–°å¯èƒ½ï¼ˆservice_roleï¼‰
CREATE POLICY "Service role can manage subscriptions"
    ON user_subscriptions FOR ALL
    USING (auth.role() = 'service_role');
```

### 2. `user_profiles` ãƒ†ãƒ¼ãƒ–ãƒ«ã«è¿½åŠ ã‚«ãƒ©ãƒ 

```sql
-- æ—¢å­˜ã®user_profilesãƒ†ãƒ¼ãƒ–ãƒ«ã«è¿½åŠ 
ALTER TABLE user_profiles
ADD COLUMN sns_links JSONB DEFAULT '[]'::jsonb,
ADD COLUMN is_online BOOLEAN DEFAULT false,
ADD COLUMN last_seen_at TIMESTAMPTZ,
ADD COLUMN subscription_tier TEXT DEFAULT 'free' CHECK (subscription_tier IN ('free', 'basic', 'premium'));

-- sns_linksã®æ§‹é€ ä¾‹:
-- [
--   {"platform": "instagram", "url": "https://instagram.com/username"},
--   {"platform": "x", "url": "https://x.com/username"},
--   {"platform": "youtube", "url": "https://youtube.com/@username"}
-- ]

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_user_profiles_subscription_tier ON user_profiles(subscription_tier);
CREATE INDEX idx_user_profiles_is_online ON user_profiles(is_online);
```

### 3. `user_blocks` ãƒ†ãƒ¼ãƒ–ãƒ«

```sql
-- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ–ãƒ­ãƒƒã‚¯ç®¡ç†ãƒ†ãƒ¼ãƒ–ãƒ«
CREATE TABLE user_blocks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    blocker_user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    blocked_user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT NOW(),

    UNIQUE(blocker_user_id, blocked_user_id),
    CHECK (blocker_user_id != blocked_user_id) -- è‡ªåˆ†è‡ªèº«ã¯ãƒ–ãƒ­ãƒƒã‚¯ä¸å¯
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_user_blocks_blocker ON user_blocks(blocker_user_id);
CREATE INDEX idx_user_blocks_blocked ON user_blocks(blocked_user_id);

-- RLSæœ‰åŠ¹åŒ–
ALTER TABLE user_blocks ENABLE ROW LEVEL SECURITY;

-- ãƒãƒªã‚·ãƒ¼: è‡ªåˆ†ãŒãƒ–ãƒ­ãƒƒã‚¯ã—ãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã¿é–²è¦§å¯èƒ½
CREATE POLICY "Users can view own blocks"
    ON user_blocks FOR SELECT
    USING (auth.uid() = blocker_user_id);

-- ãƒãƒªã‚·ãƒ¼: ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã¿ä½œæˆãƒ»å‰Šé™¤å¯èƒ½
CREATE POLICY "Premium users can manage blocks"
    ON user_blocks FOR ALL
    USING (
        auth.uid() = blocker_user_id AND
        EXISTS (
            SELECT 1 FROM user_profiles
            WHERE user_id = auth.uid()
            AND subscription_tier = 'premium'
        )
    );
```

### 4. RLSãƒãƒªã‚·ãƒ¼ã®æ›´æ–°ï¼ˆæŠ•ç¨¿ã®é–²è¦§åˆ¶é™ï¼‰

```sql
-- æ—¢å­˜ã®postsãƒ†ãƒ¼ãƒ–ãƒ«ã®SELECTãƒãƒªã‚·ãƒ¼ã‚’æ›´æ–°
-- ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯æŠ•ç¨¿ã‚’è¦‹ã‚Œãªã„
DROP POLICY IF EXISTS "Posts are viewable by everyone" ON posts;

CREATE POLICY "Posts are viewable by non-blocked users"
    ON posts FOR SELECT
    USING (
        -- è‡ªåˆ†ã®æŠ•ç¨¿ã¯å¸¸ã«è¦‹ãˆã‚‹
        auth.uid() = user_id
        OR
        -- ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ãªã„æŠ•ç¨¿ã®ã¿è¦‹ãˆã‚‹
        NOT EXISTS (
            SELECT 1 FROM user_blocks
            WHERE blocker_user_id = posts.user_id
            AND blocked_user_id = auth.uid()
        )
    );
```

### 5. é–¢æ•°: ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³çŠ¶æ…‹å–å¾—

```sql
-- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãƒ†ã‚£ã‚¢ã‚’å–å¾—ã™ã‚‹é–¢æ•°
CREATE OR REPLACE FUNCTION get_user_subscription_tier(target_user_id UUID)
RETURNS TEXT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    tier TEXT;
BEGIN
    SELECT subscription_tier INTO tier
    FROM user_profiles
    WHERE user_id = target_user_id;

    RETURN COALESCE(tier, 'free');
END;
$$;

-- æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°
CREATE OR REPLACE FUNCTION has_active_subscription(target_user_id UUID, required_tier TEXT)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    current_tier TEXT;
BEGIN
    SELECT subscription_tier INTO current_tier
    FROM user_profiles
    WHERE user_id = target_user_id;

    -- ãƒ†ã‚£ã‚¢ã®å„ªå…ˆé †ä½: premium > basic > free
    IF required_tier = 'basic' THEN
        RETURN current_tier IN ('basic', 'premium');
    ELSIF required_tier = 'premium' THEN
        RETURN current_tier = 'premium';
    ELSE
        RETURN true; -- free tier
    END IF;
END;
$$;
```

---

## ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰å®Ÿè£…

### 1. Rust API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ

#### `services/api_rust/src/api/handlers/subscription.rs`

```rust
use axum::{Extension, Json};
use serde::{Deserialize, Serialize};
use crate::{AppState, error::{AppError, AppResult}, api::middleware::AuthUser};

// ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãƒ†ã‚£ã‚¢ã®å®šç¾©
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum SubscriptionTier {
    Free,
    Basic,
    Premium,
}

// ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³æƒ…å ±ãƒ¬ã‚¹ãƒãƒ³ã‚¹
#[derive(Debug, Serialize)]
pub struct SubscriptionInfo {
    pub tier: SubscriptionTier,
    pub expires_at: Option<String>,
    pub auto_renewing: bool,
    pub status: String,
}

// GET /subscription/status - è‡ªåˆ†ã®ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³æƒ…å ±ã‚’å–å¾—
pub async fn get_subscription_status(
    State(state): State<AppState>,
    Extension(user): Extension<AuthUser>,
) -> AppResult<Json<SubscriptionInfo>> {
    crate::api::validation::validate_uuid(&user.user_id)?;

    let query = format!("user_id=eq.{}&select=*", user.user_id);
    let subscriptions: Vec<serde_json::Value> = state
        .supabase
        .select("user_subscriptions", &query, &user.token)
        .await?;

    if subscriptions.is_empty() {
        // ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãªã— = ç„¡æ–™ãƒ—ãƒ©ãƒ³
        return Ok(Json(SubscriptionInfo {
            tier: SubscriptionTier::Free,
            expires_at: None,
            auto_renewing: false,
            status: "free".to_string(),
        }));
    }

    let sub = &subscriptions[0];
    let tier_str = sub["subscription_tier"].as_str().unwrap_or("free");
    let tier = match tier_str {
        "basic" => SubscriptionTier::Basic,
        "premium" => SubscriptionTier::Premium,
        _ => SubscriptionTier::Free,
    };

    Ok(Json(SubscriptionInfo {
        tier,
        expires_at: sub["expires_at"].as_str().map(|s| s.to_string()),
        auto_renewing: sub["auto_renewing"].as_bool().unwrap_or(false),
        status: sub["status"].as_str().unwrap_or("unknown").to_string(),
    }))
}

// POST /subscription/verify - Google Playè³¼å…¥ãƒˆãƒ¼ã‚¯ãƒ³ã®æ¤œè¨¼
#[derive(Debug, Deserialize)]
pub struct VerifyPurchaseRequest {
    pub product_id: String,      // "basic_monthly" or "premium_monthly"
    pub purchase_token: String,  // Google Playè³¼å…¥ãƒˆãƒ¼ã‚¯ãƒ³
    pub platform: String,        // "android" or "ios"
}

pub async fn verify_purchase(
    State(state): State<AppState>,
    Extension(user): Extension<AuthUser>,
    Json(req): Json<VerifyPurchaseRequest>,
) -> AppResult<Json<serde_json::Value>> {
    crate::api::validation::validate_uuid(&user.user_id)?;

    // TODO: Google Play Billing APIã§ãƒˆãƒ¼ã‚¯ãƒ³æ¤œè¨¼
    // - purchase_tokenã‚’Google Play Developer APIã§æ¤œè¨¼
    // - æœ‰åŠ¹æœŸé™ã€è‡ªå‹•æ›´æ–°çŠ¶æ…‹ã‚’å–å¾—
    // - user_subscriptionsãƒ†ãƒ¼ãƒ–ãƒ«ã«ä¿å­˜/æ›´æ–°

    // ä»®å®Ÿè£…ï¼ˆå®Ÿéš›ã¯Google APIã‚’å‘¼ã¶ï¼‰
    let tier = if req.product_id.contains("premium") {
        "premium"
    } else if req.product_id.contains("basic") {
        "basic"
    } else {
        return Err(AppError::BadRequest("Invalid product_id".to_string()));
    };

    // ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³æƒ…å ±ã‚’ä¿å­˜
    let subscription_data = serde_json::json!({
        "user_id": user.user_id,
        "subscription_tier": tier,
        "platform": req.platform,
        "product_id": req.product_id,
        "purchase_token": req.purchase_token,
        "starts_at": chrono::Utc::now().to_rfc3339(),
        "expires_at": (chrono::Utc::now() + chrono::Duration::days(30)).to_rfc3339(),
        "auto_renewing": true,
        "status": "active",
    });

    // UPSERT (æ—¢å­˜ãŒã‚ã‚Œã°æ›´æ–°ã€ãªã‘ã‚Œã°æŒ¿å…¥)
    state.supabase.upsert(
        "user_subscriptions",
        &subscription_data,
        "user_id",
        &user.token
    ).await?;

    // user_profilesã®subscription_tierã‚‚æ›´æ–°
    let profile_update = serde_json::json!({
        "subscription_tier": tier,
    });
    state.supabase.update(
        "user_profiles",
        &format!("user_id=eq.{}", user.user_id),
        &profile_update,
        &user.token
    ).await?;

    Ok(Json(serde_json::json!({
        "success": true,
        "tier": tier,
    })))
}

// POST /subscription/restore - è³¼å…¥ã®å¾©å…ƒ
pub async fn restore_purchase(
    State(state): State<AppState>,
    Extension(user): Extension<AuthUser>,
) -> AppResult<Json<SubscriptionInfo>> {
    crate::api::validation::validate_uuid(&user.user_id)?;

    // TODO: Google Play Billing APIã§è³¼å…¥å±¥æ­´ã‚’å–å¾—
    // - æœ€æ–°ã®æœ‰åŠ¹ãªã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã‚’å–å¾—
    // - user_subscriptionsã«åæ˜ 

    // ç¾çŠ¶ã®ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³æƒ…å ±ã‚’è¿”ã™
    get_subscription_status(State(state), Extension(user)).await
}
```

#### `services/api_rust/src/api/handlers/users.rs` ã«è¿½åŠ 

```rust
// PATCH /users/profile/sns-links - SNSãƒªãƒ³ã‚¯æ›´æ–°ï¼ˆãƒ™ãƒ¼ã‚·ãƒƒã‚¯ãƒ—ãƒ©ãƒ³ä»¥ä¸Šï¼‰
#[derive(Debug, Deserialize)]
pub struct UpdateSnsLinksRequest {
    pub sns_links: Vec<SnsLink>,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct SnsLink {
    pub platform: String, // "instagram", "x", "youtube", etc.
    pub url: String,
}

pub async fn update_sns_links(
    State(state): State<AppState>,
    Extension(user): Extension<AuthUser>,
    Json(req): Json<UpdateSnsLinksRequest>,
) -> AppResult<Json<MessageResponse>> {
    crate::api::validation::validate_uuid(&user.user_id)?;

    // ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãƒ†ã‚£ã‚¢ã‚’ãƒã‚§ãƒƒã‚¯
    let profile_query = format!("user_id=eq.{}&select=subscription_tier", user.user_id);
    let profiles: Vec<serde_json::Value> = state
        .supabase
        .select("user_profiles", &profile_query, &user.token)
        .await?;

    if profiles.is_empty() {
        return Err(AppError::NotFound);
    }

    let tier = profiles[0]["subscription_tier"].as_str().unwrap_or("free");
    if tier == "free" {
        return Err(AppError::BadRequest(
            "ãƒ™ãƒ¼ã‚·ãƒƒã‚¯ãƒ—ãƒ©ãƒ³ä»¥ä¸ŠãŒå¿…è¦ã§ã™".to_string()
        ));
    }

    // URLæ¤œè¨¼
    for link in &req.sns_links {
        if !link.url.starts_with("http://") && !link.url.starts_with("https://") {
            return Err(AppError::Validation(
                format!("ç„¡åŠ¹ãªURL: {}", link.url)
            ));
        }
        // æœ€å¤§5å€‹ã¾ã§
        if req.sns_links.len() > 5 {
            return Err(AppError::Validation(
                "SNSãƒªãƒ³ã‚¯ã¯æœ€å¤§5å€‹ã¾ã§ã§ã™".to_string()
            ));
        }
    }

    // æ›´æ–°
    let update_data = serde_json::json!({
        "sns_links": req.sns_links,
    });

    state.supabase.update(
        "user_profiles",
        &format!("user_id=eq.{}", user.user_id),
        &update_data,
        &user.token
    ).await?;

    Ok(Json(MessageResponse {
        message: "SNSãƒªãƒ³ã‚¯ã‚’æ›´æ–°ã—ã¾ã—ãŸ".to_string(),
    }))
}
```

#### `services/api_rust/src/api/handlers/blocks.rs` (æ–°è¦ä½œæˆ)

```rust
use axum::{Extension, Json, extract::{Path, State}};
use serde::{Deserialize, Serialize};
use crate::{AppState, error::{AppError, AppResult}, api::middleware::AuthUser};

// POST /blocks - ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆãƒ—ãƒ¬ãƒŸã‚¢ãƒ ã®ã¿ï¼‰
#[derive(Debug, Deserialize)]
pub struct BlockUserRequest {
    pub blocked_user_id: String,
}

#[derive(Debug, Serialize)]
pub struct BlockResponse {
    pub success: bool,
    pub message: String,
}

pub async fn block_user(
    State(state): State<AppState>,
    Extension(user): Extension<AuthUser>,
    Json(req): Json<BlockUserRequest>,
) -> AppResult<Json<BlockResponse>> {
    crate::api::validation::validate_uuid(&user.user_id)?;
    crate::api::validation::validate_uuid(&req.blocked_user_id)?;

    // è‡ªåˆ†è‡ªèº«ã¯ãƒ–ãƒ­ãƒƒã‚¯ä¸å¯
    if user.user_id == req.blocked_user_id {
        return Err(AppError::BadRequest("è‡ªåˆ†è‡ªèº«ã¯ãƒ–ãƒ­ãƒƒã‚¯ã§ãã¾ã›ã‚“".to_string()));
    }

    // ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ãƒ—ãƒ©ãƒ³ãƒã‚§ãƒƒã‚¯
    let profile_query = format!("user_id=eq.{}&select=subscription_tier", user.user_id);
    let profiles: Vec<serde_json::Value> = state
        .supabase
        .select("user_profiles", &profile_query, &user.token)
        .await?;

    if profiles.is_empty() {
        return Err(AppError::NotFound);
    }

    let tier = profiles[0]["subscription_tier"].as_str().unwrap_or("free");
    if tier != "premium" {
        return Err(AppError::BadRequest(
            "ã“ã®æ©Ÿèƒ½ã¯ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ãƒ—ãƒ©ãƒ³é™å®šã§ã™".to_string()
        ));
    }

    // ãƒ–ãƒ­ãƒƒã‚¯è¿½åŠ 
    let block_data = serde_json::json!({
        "blocker_user_id": user.user_id,
        "blocked_user_id": req.blocked_user_id,
    });

    state.supabase.insert(
        "user_blocks",
        &block_data,
        &user.token
    ).await?;

    Ok(Json(BlockResponse {
        success: true,
        message: "ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã—ãŸ".to_string(),
    }))
}

// DELETE /blocks/:blocked_user_id - ãƒ–ãƒ­ãƒƒã‚¯è§£é™¤
pub async fn unblock_user(
    State(state): State<AppState>,
    Extension(user): Extension<AuthUser>,
    Path(blocked_user_id): Path<String>,
) -> AppResult<Json<BlockResponse>> {
    crate::api::validation::validate_uuid(&user.user_id)?;
    crate::api::validation::validate_uuid(&blocked_user_id)?;

    let delete_query = format!(
        "blocker_user_id=eq.{}&blocked_user_id=eq.{}",
        user.user_id, blocked_user_id
    );

    state.supabase.delete("user_blocks", &delete_query, &user.token).await?;

    Ok(Json(BlockResponse {
        success: true,
        message: "ãƒ–ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ã—ã¾ã—ãŸ".to_string(),
    }))
}

// GET /blocks - è‡ªåˆ†ãŒãƒ–ãƒ­ãƒƒã‚¯ã—ãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§
pub async fn list_blocked_users(
    State(state): State<AppState>,
    Extension(user): Extension<AuthUser>,
) -> AppResult<Json<Vec<serde_json::Value>>> {
    crate::api::validation::validate_uuid(&user.user_id)?;

    let query = format!(
        "blocker_user_id=eq.{}&select=blocked_user_id,created_at",
        user.user_id
    );

    let blocks = state.supabase.select("user_blocks", &query, &user.token).await?;

    Ok(Json(blocks))
}
```

### 2. ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°è¿½åŠ 

#### `services/api_rust/src/api/routes/mod.rs`

```rust
// ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³é–¢é€£ãƒ«ãƒ¼ãƒˆ
fn subscription_routes(state: AppState) -> Router<AppState> {
    Router::new()
        .route("/status", get(handlers::get_subscription_status))
        .route("/verify", post(handlers::verify_purchase))
        .route("/restore", post(handlers::restore_purchase))
        .route_layer(middleware::from_fn_with_state(state, auth_middleware))
}

// ãƒ–ãƒ­ãƒƒã‚¯é–¢é€£ãƒ«ãƒ¼ãƒˆ
fn blocks_routes(state: AppState) -> Router<AppState> {
    Router::new()
        .route("/", get(handlers::list_blocked_users).post(handlers::block_user))
        .route("/:blocked_user_id", delete(handlers::unblock_user))
        .route_layer(middleware::from_fn_with_state(state, auth_middleware))
}

// ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ã‚¿ãƒ¼ã«è¿½åŠ 
pub fn create_routes(state: AppState) -> Router<AppState> {
    Router::new()
        // ... æ—¢å­˜ã®ãƒ«ãƒ¼ãƒˆ
        .nest("/subscription", subscription_routes(state.clone()))
        .nest("/blocks", blocks_routes(state.clone()))
}
```

---

## ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰å®Ÿè£…

### 1. ä¾å­˜é–¢ä¿‚è¿½åŠ 

#### `apps/mobile_flutter/pubspec.yaml`

```yaml
dependencies:
  # æ—¢å­˜ã®ä¾å­˜é–¢ä¿‚...

  # In-App Purchase
  in_app_purchase: ^3.2.0
  in_app_purchase_android: ^0.3.6+5
  in_app_purchase_storekit: ^0.3.17+3
```

### 2. ãƒ¢ãƒ‡ãƒ«å®šç¾©

#### `lib/data/models/subscription_models.dart`

```dart
enum SubscriptionTier {
  free,
  basic,
  premium;

  String get displayName {
    switch (this) {
      case SubscriptionTier.free:
        return 'ç„¡æ–™';
      case SubscriptionTier.basic:
        return 'ãƒ™ãƒ¼ã‚·ãƒƒã‚¯';
      case SubscriptionTier.premium:
        return 'ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ';
    }
  }

  String get price {
    switch (this) {
      case SubscriptionTier.free:
        return 'Â¥0';
      case SubscriptionTier.basic:
        return 'Â¥1,000/æœˆ';
      case SubscriptionTier.premium:
        return 'Â¥3,000/æœˆ';
    }
  }

  List<String> get features {
    switch (this) {
      case SubscriptionTier.free:
        return [
          'åŸºæœ¬æ©Ÿèƒ½',
          'ãƒ¯ãƒ¼ã‚¯ã‚¢ã‚¦ãƒˆè¨˜éŒ²',
          'é£Ÿäº‹è¨˜éŒ²',
          'AIç›¸è«‡ï¼ˆåˆ¶é™ã‚ã‚Šï¼‰',
        ];
      case SubscriptionTier.basic:
        return [
          'ç„¡æ–™ãƒ—ãƒ©ãƒ³ã®ã™ã¹ã¦',
          'ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã«SNS URLè¡¨ç¤º',
          'ä»–ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®é£Ÿäº‹ãƒ¡ãƒ‹ãƒ¥ãƒ¼é–²è¦§',
        ];
      case SubscriptionTier.premium:
        return [
          'ãƒ™ãƒ¼ã‚·ãƒƒã‚¯ãƒ—ãƒ©ãƒ³ã®ã™ã¹ã¦',
          'ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ç¢ºèª',
          'ãƒ–ãƒ­ãƒƒã‚¯æ©Ÿèƒ½',
          'ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ãƒãƒƒã‚¸',
        ];
    }
  }

  String get productId {
    switch (this) {
      case SubscriptionTier.basic:
        return 'basic_monthly';
      case SubscriptionTier.premium:
        return 'premium_monthly';
      case SubscriptionTier.free:
        return '';
    }
  }
}

class SubscriptionInfo {
  final SubscriptionTier tier;
  final DateTime? expiresAt;
  final bool autoRenewing;
  final String status;

  const SubscriptionInfo({
    required this.tier,
    this.expiresAt,
    required this.autoRenewing,
    required this.status,
  });

  factory SubscriptionInfo.fromJson(Map<String, dynamic> json) {
    return SubscriptionInfo(
      tier: SubscriptionTier.values.firstWhere(
        (e) => e.name == json['tier'],
        orElse: () => SubscriptionTier.free,
      ),
      expiresAt: json['expires_at'] != null
          ? DateTime.parse(json['expires_at'])
          : null,
      autoRenewing: json['auto_renewing'] ?? false,
      status: json['status'] ?? 'free',
    );
  }

  bool get isActive =>
      status == 'active' &&
      (expiresAt == null || expiresAt!.isAfter(DateTime.now()));

  bool hasFeature(String feature) {
    switch (feature) {
      case 'sns_links':
        return tier == SubscriptionTier.basic || tier == SubscriptionTier.premium;
      case 'view_meals':
        return tier == SubscriptionTier.basic || tier == SubscriptionTier.premium;
      case 'online_status':
        return tier == SubscriptionTier.premium;
      case 'block_users':
        return tier == SubscriptionTier.premium;
      default:
        return false;
    }
  }
}

class SnsLink {
  final String platform;
  final String url;

  const SnsLink({
    required this.platform,
    required this.url,
  });

  factory SnsLink.fromJson(Map<String, dynamic> json) {
    return SnsLink(
      platform: json['platform'],
      url: json['url'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'platform': platform,
      'url': url,
    };
  }

  String get iconAsset {
    switch (platform.toLowerCase()) {
      case 'instagram':
        return 'assets/icons/instagram.svg';
      case 'x':
      case 'twitter':
        return 'assets/icons/x.svg';
      case 'youtube':
        return 'assets/icons/youtube.svg';
      case 'tiktok':
        return 'assets/icons/tiktok.svg';
      default:
        return 'assets/icons/link.svg';
    }
  }
}
```

### 3. ã‚µãƒ¼ãƒ“ã‚¹å±¤

#### `lib/data/services/subscription_service.dart`

```dart
import 'dart:async';
import 'package:dio/dio.dart';
import 'package:in_app_purchase/in_app_purchase.dart';
import 'package:in_app_purchase_android/in_app_purchase_android.dart';
import '../models/subscription_models.dart';

class SubscriptionService {
  final Dio _dio;
  final InAppPurchase _iap = InAppPurchase.instance;

  // å•†å“ID
  static const String basicMonthlyId = 'basic_monthly';
  static const String premiumMonthlyId = 'premium_monthly';
  static const Set<String> _productIds = {basicMonthlyId, premiumMonthlyId};

  // è³¼å…¥ã‚¹ãƒˆãƒªãƒ¼ãƒ 
  StreamSubscription<List<PurchaseDetails>>? _subscription;

  SubscriptionService(this._dio);

  /// åˆæœŸåŒ–
  Future<void> initialize() async {
    final available = await _iap.isAvailable();
    if (!available) {
      throw Exception('In-App Purchase not available');
    }

    // è³¼å…¥ãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®š
    _subscription = _iap.purchaseStream.listen(
      _onPurchaseUpdate,
      onDone: () => _subscription?.cancel(),
      onError: (error) => print('Purchase stream error: $error'),
    );
  }

  /// è³¼å…¥ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†
  Future<void> _onPurchaseUpdate(List<PurchaseDetails> purchases) async {
    for (var purchase in purchases) {
      if (purchase.status == PurchaseStatus.purchased ||
          purchase.status == PurchaseStatus.restored) {
        // ã‚µãƒ¼ãƒãƒ¼ã§æ¤œè¨¼
        await _verifyPurchase(purchase);
      }

      if (purchase.pendingCompletePurchase) {
        await _iap.completePurchase(purchase);
      }
    }
  }

  /// ã‚µãƒ¼ãƒãƒ¼ã§è³¼å…¥ã‚’æ¤œè¨¼
  Future<void> _verifyPurchase(PurchaseDetails purchase) async {
    try {
      String? purchaseToken;
      if (purchase is GooglePlayPurchaseDetails) {
        purchaseToken = purchase.billingClientPurchase.purchaseToken;
      }

      await _dio.post(
        '/subscription/verify',
        data: {
          'product_id': purchase.productID,
          'purchase_token': purchaseToken,
          'platform': 'android',
        },
      );
    } catch (e) {
      print('Purchase verification failed: $e');
      rethrow;
    }
  }

  /// åˆ©ç”¨å¯èƒ½ãªå•†å“ã‚’å–å¾—
  Future<List<ProductDetails>> getProducts() async {
    final response = await _iap.queryProductDetails(_productIds);

    if (response.error != null) {
      throw Exception('Failed to query products: ${response.error}');
    }

    return response.productDetails;
  }

  /// è³¼å…¥é–‹å§‹
  Future<void> purchaseSubscription(ProductDetails product) async {
    final purchaseParam = PurchaseParam(productDetails: product);
    await _iap.buyNonConsumable(purchaseParam: purchaseParam);
  }

  /// è³¼å…¥ã®å¾©å…ƒ
  Future<void> restorePurchases() async {
    try {
      await _iap.restorePurchases();

      // ã‚µãƒ¼ãƒãƒ¼å´ã§ã‚‚å¾©å…ƒ
      await _dio.post('/subscription/restore');
    } catch (e) {
      print('Restore failed: $e');
      rethrow;
    }
  }

  /// ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³æƒ…å ±ã‚’å–å¾—
  Future<SubscriptionInfo> getSubscriptionInfo() async {
    try {
      final response = await _dio.get('/subscription/status');
      return SubscriptionInfo.fromJson(response.data);
    } catch (e) {
      print('Failed to get subscription info: $e');
      rethrow;
    }
  }

  /// ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
  void dispose() {
    _subscription?.cancel();
  }
}
```

#### `lib/data/services/block_service.dart`

```dart
import 'package:dio/dio.dart';

class BlockService {
  final Dio _dio;

  BlockService(this._dio);

  /// ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ãƒ–ãƒ­ãƒƒã‚¯
  Future<void> blockUser(String userId) async {
    await _dio.post('/blocks', data: {'blocked_user_id': userId});
  }

  /// ãƒ–ãƒ­ãƒƒã‚¯è§£é™¤
  Future<void> unblockUser(String userId) async {
    await _dio.delete('/blocks/$userId');
  }

  /// ãƒ–ãƒ­ãƒƒã‚¯ã—ãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§ã‚’å–å¾—
  Future<List<String>> getBlockedUsers() async {
    final response = await _dio.get('/blocks');
    return (response.data as List)
        .map((e) => e['blocked_user_id'] as String)
        .toList();
  }

  /// ç‰¹å®šã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
  Future<bool> isUserBlocked(String userId) async {
    final blockedUsers = await getBlockedUsers();
    return blockedUsers.contains(userId);
  }
}
```

### 4. ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼ï¼ˆRiverpodï¼‰

#### `lib/presentation/providers/subscription_provider.dart`

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:in_app_purchase/in_app_purchase.dart';
import '../../data/models/subscription_models.dart';
import '../../data/services/subscription_service.dart';
import 'api_provider.dart';

// ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã‚µãƒ¼ãƒ“ã‚¹ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼
final subscriptionServiceProvider = Provider<SubscriptionService>((ref) {
  final dio = ref.watch(dioProvider);
  return SubscriptionService(dio);
});

// ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³æƒ…å ±ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼
final subscriptionInfoProvider = FutureProvider<SubscriptionInfo>((ref) async {
  final service = ref.watch(subscriptionServiceProvider);
  return await service.getSubscriptionInfo();
});

// åˆ©ç”¨å¯èƒ½ãªå•†å“ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼
final availableProductsProvider = FutureProvider<List<ProductDetails>>((ref) async {
  final service = ref.watch(subscriptionServiceProvider);
  await service.initialize();
  return await service.getProducts();
});

// è³¼å…¥å‡¦ç†ãƒ—ãƒ­ãƒã‚¤ãƒ€ãƒ¼
final purchaseControllerProvider = StateNotifierProvider<PurchaseController, AsyncValue<void>>((ref) {
  final service = ref.watch(subscriptionServiceProvider);
  return PurchaseController(service);
});

class PurchaseController extends StateNotifier<AsyncValue<void>> {
  final SubscriptionService _service;

  PurchaseController(this._service) : super(const AsyncValue.data(null));

  Future<void> purchase(ProductDetails product) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      await _service.purchaseSubscription(product);
    });
  }

  Future<void> restore() async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      await _service.restorePurchases();
    });
  }
}
```

### 5. UIå®Ÿè£…

#### `lib/presentation/pages/subscription/subscription_page.dart`

```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../providers/subscription_provider.dart';
import '../../../data/models/subscription_models.dart';

class SubscriptionPage extends ConsumerWidget {
  const SubscriptionPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final subscriptionAsync = ref.watch(subscriptionInfoProvider);
    final productsAsync = ref.watch(availableProductsProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('ãƒ—ãƒ©ãƒ³å¤‰æ›´'),
        actions: [
          TextButton(
            onPressed: () async {
              await ref.read(purchaseControllerProvider.notifier).restore();
              ref.invalidate(subscriptionInfoProvider);
            },
            child: const Text('è³¼å…¥ã‚’å¾©å…ƒ'),
          ),
        ],
      ),
      body: subscriptionAsync.when(
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(child: Text('ã‚¨ãƒ©ãƒ¼: $error')),
        data: (currentSubscription) {
          return productsAsync.when(
            loading: () => const Center(child: CircularProgressIndicator()),
            error: (error, stack) => Center(child: Text('å•†å“ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—: $error')),
            data: (products) {
              return ListView(
                padding: const EdgeInsets.all(16),
                children: [
                  // ç¾åœ¨ã®ãƒ—ãƒ©ãƒ³è¡¨ç¤º
                  _CurrentPlanCard(subscription: currentSubscription),
                  const SizedBox(height: 24),

                  // ãƒ—ãƒ©ãƒ³ä¸€è¦§
                  _PlanCard(
                    tier: SubscriptionTier.free,
                    isCurrent: currentSubscription.tier == SubscriptionTier.free,
                    onSelect: null, // ç„¡æ–™ãƒ—ãƒ©ãƒ³ã¯é¸æŠä¸å¯
                  ),
                  const SizedBox(height: 16),
                  _PlanCard(
                    tier: SubscriptionTier.basic,
                    isCurrent: currentSubscription.tier == SubscriptionTier.basic,
                    product: products.firstWhere(
                      (p) => p.id == SubscriptionTier.basic.productId,
                      orElse: () => products.first,
                    ),
                    onSelect: (product) async {
                      await ref.read(purchaseControllerProvider.notifier).purchase(product);
                      ref.invalidate(subscriptionInfoProvider);
                    },
                  ),
                  const SizedBox(height: 16),
                  _PlanCard(
                    tier: SubscriptionTier.premium,
                    isCurrent: currentSubscription.tier == SubscriptionTier.premium,
                    product: products.firstWhere(
                      (p) => p.id == SubscriptionTier.premium.productId,
                      orElse: () => products.last,
                    ),
                    onSelect: (product) async {
                      await ref.read(purchaseControllerProvider.notifier).purchase(product);
                      ref.invalidate(subscriptionInfoProvider);
                    },
                  ),
                ],
              );
            },
          );
        },
      ),
    );
  }
}

class _CurrentPlanCard extends StatelessWidget {
  final SubscriptionInfo subscription;

  const _CurrentPlanCard({required this.subscription});

  @override
  Widget build(BuildContext context) {
    return Card(
      color: const Color(0xFF323232),
      child: Padding(
        padding: const EdgeInsets.all(16),
        children: [
          const Text(
            'ç¾åœ¨ã®ãƒ—ãƒ©ãƒ³',
            style: TextStyle(
              fontSize: 14,
              color: Colors.white70,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            subscription.tier.displayName,
            style: const TextStyle(
              fontSize: 24,
              fontWeight: FontWeight.bold,
              color: Colors.white,
            ),
          ),
          if (subscription.expiresAt != null) ...[
            const SizedBox(height: 8),
            Text(
              'æœ‰åŠ¹æœŸé™: ${subscription.expiresAt!.toString().split(' ')[0]}',
              style: const TextStyle(
                fontSize: 12,
                color: Colors.white70,
              ),
            ),
          ],
        ],
      ),
    );
  }
}

class _PlanCard extends StatelessWidget {
  final SubscriptionTier tier;
  final bool isCurrent;
  final ProductDetails? product;
  final Function(ProductDetails)? onSelect;

  const _PlanCard({
    required this.tier,
    required this.isCurrent,
    this.product,
    this.onSelect,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      color: isCurrent ? const Color(0xFF323232) : Colors.white,
      child: Padding(
        padding: const EdgeInsets.all(16),
        children: [
          Row(
            children: [
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      tier.displayName,
                      style: TextStyle(
                        fontSize: 20,
                        fontWeight: FontWeight.bold,
                        color: isCurrent ? Colors.white : Colors.black,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      product?.price ?? tier.price,
                      style: TextStyle(
                        fontSize: 16,
                        color: isCurrent ? Colors.white70 : Colors.black54,
                      ),
                    ),
                  ],
                ),
              ),
              if (isCurrent)
                Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 6,
                  ),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: const Text(
                    'ç¾åœ¨ã®ãƒ—ãƒ©ãƒ³',
                    style: TextStyle(
                      fontSize: 12,
                      fontWeight: FontWeight.bold,
                      color: Color(0xFF323232),
                    ),
                  ),
                ),
            ],
          ),
          const SizedBox(height: 16),
          ...tier.features.map((feature) => Padding(
            padding: const EdgeInsets.only(bottom: 8),
            child: Row(
              children: [
                Icon(
                  Icons.check_circle,
                  size: 16,
                  color: isCurrent ? Colors.white : const Color(0xFF323232),
                ),
                const SizedBox(width: 8),
                Text(
                  feature,
                  style: TextStyle(
                    fontSize: 14,
                    color: isCurrent ? Colors.white : Colors.black87,
                  ),
                ),
              ],
            ),
          )),
          if (!isCurrent && onSelect != null && product != null) ...[
            const SizedBox(height: 16),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: () => onSelect!(product!),
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFF323232),
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(vertical: 12),
                ),
                child: const Text('ã“ã®ãƒ—ãƒ©ãƒ³ã«ã™ã‚‹'),
              ),
            ),
          ],
        ],
      ),
    );
  }
}
```

#### `lib/presentation/pages/settings/sns_links_edit_page.dart`

```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../data/models/subscription_models.dart';

class SnsLinksEditPage extends ConsumerStatefulWidget {
  final List<SnsLink> initialLinks;

  const SnsLinksEditPage({
    super.key,
    required this.initialLinks,
  });

  @override
  ConsumerState<SnsLinksEditPage> createState() => _SnsLinksEditPageState();
}

class _SnsLinksEditPageState extends ConsumerState<SnsLinksEditPage> {
  late List<SnsLink> _links;
  final _formKey = GlobalKey<FormState>();

  static const _platforms = [
    'Instagram',
    'X (Twitter)',
    'YouTube',
    'TikTok',
    'ãã®ä»–',
  ];

  @override
  void initState() {
    super.initState();
    _links = List.from(widget.initialLinks);
  }

  void _addLink() {
    if (_links.length >= 5) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('SNSãƒªãƒ³ã‚¯ã¯æœ€å¤§5å€‹ã¾ã§ã§ã™')),
      );
      return;
    }

    setState(() {
      _links.add(const SnsLink(platform: 'Instagram', url: ''));
    });
  }

  void _removeLink(int index) {
    setState(() {
      _links.removeAt(index);
    });
  }

  Future<void> _save() async {
    if (!_formKey.currentState!.validate()) return;

    try {
      // TODO: APIå‘¼ã³å‡ºã—
      // await ref.read(userServiceProvider).updateSnsLinks(_links);

      Navigator.of(context).pop(_links);
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: $e')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('SNSãƒªãƒ³ã‚¯ç·¨é›†'),
        actions: [
          TextButton(
            onPressed: _save,
            child: const Text('ä¿å­˜'),
          ),
        ],
      ),
      body: Form(
        key: _formKey,
        child: ListView(
          padding: const EdgeInsets.all(16),
          children: [
            const Text(
              'ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã«è¡¨ç¤ºã™ã‚‹SNSãƒªãƒ³ã‚¯ã‚’è¿½åŠ ã§ãã¾ã™ï¼ˆæœ€å¤§5å€‹ï¼‰',
              style: TextStyle(color: Colors.white70),
            ),
            const SizedBox(height: 24),
            ..._links.asMap().entries.map((entry) {
              final index = entry.key;
              final link = entry.value;
              return _LinkEditCard(
                key: ValueKey(index),
                link: link,
                platforms: _platforms,
                onChanged: (newLink) {
                  setState(() {
                    _links[index] = newLink;
                  });
                },
                onRemove: () => _removeLink(index),
              );
            }),
            const SizedBox(height: 16),
            OutlinedButton.icon(
              onPressed: _addLink,
              icon: const Icon(Icons.add),
              label: const Text('SNSãƒªãƒ³ã‚¯ã‚’è¿½åŠ '),
              style: OutlinedButton.styleFrom(
                foregroundColor: Colors.white,
                side: const BorderSide(color: Colors.white30),
              ),
            ),
          ],
        ),
      ),
      backgroundColor: Colors.black,
    );
  }
}

class _LinkEditCard extends StatefulWidget {
  final SnsLink link;
  final List<String> platforms;
  final Function(SnsLink) onChanged;
  final VoidCallback onRemove;

  const _LinkEditCard({
    super.key,
    required this.link,
    required this.platforms,
    required this.onChanged,
    required this.onRemove,
  });

  @override
  State<_LinkEditCard> createState() => _LinkEditCardState();
}

class _LinkEditCardState extends State<_LinkEditCard> {
  late TextEditingController _urlController;
  late String _selectedPlatform;

  @override
  void initState() {
    super.initState();
    _urlController = TextEditingController(text: widget.link.url);
    _selectedPlatform = widget.link.platform;
  }

  @override
  void dispose() {
    _urlController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Card(
      color: const Color(0xFF323232),
      margin: const EdgeInsets.only(bottom: 16),
      child: Padding(
        padding: const EdgeInsets.all(16),
        children: [
          Row(
            children: [
              Expanded(
                child: DropdownButtonFormField<String>(
                  value: _selectedPlatform,
                  decoration: const InputDecoration(
                    labelText: 'ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ',
                    border: OutlineInputBorder(),
                  ),
                  dropdownColor: const Color(0xFF323232),
                  items: widget.platforms.map((platform) {
                    return DropdownMenuItem(
                      value: platform,
                      child: Text(platform),
                    );
                  }).toList(),
                  onChanged: (value) {
                    if (value != null) {
                      setState(() {
                        _selectedPlatform = value;
                      });
                      widget.onChanged(
                        SnsLink(platform: value, url: _urlController.text),
                      );
                    }
                  },
                ),
              ),
              IconButton(
                icon: const Icon(Icons.delete),
                onPressed: widget.onRemove,
                color: Colors.red,
              ),
            ],
          ),
          const SizedBox(height: 12),
          TextFormField(
            controller: _urlController,
            decoration: const InputDecoration(
              labelText: 'URL',
              hintText: 'https://...',
              border: OutlineInputBorder(),
            ),
            validator: (value) {
              if (value == null || value.isEmpty) {
                return 'URLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„';
              }
              if (!value.startsWith('http://') && !value.startsWith('https://')) {
                return 'æœ‰åŠ¹ãªURLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„';
              }
              return null;
            },
            onChanged: (value) {
              widget.onChanged(
                SnsLink(platform: _selectedPlatform, url: value),
              );
            },
          ),
        ],
      ),
    );
  }
}
```

---

## Google Play Consoleè¨­å®š

### 1. ã‚¢ãƒ—ãƒªå†…èª²é‡‘ã®æœ‰åŠ¹åŒ–

1. **Google Play Console**ã«ã‚¢ã‚¯ã‚»ã‚¹
2. ã‚¢ãƒ—ãƒªã‚’é¸æŠ
3. **åç›ŠåŒ– â†’ ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆ â†’ ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³**

### 2. ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³å•†å“ã®ä½œæˆ

#### ãƒ™ãƒ¼ã‚·ãƒƒã‚¯ãƒ—ãƒ©ãƒ³
- **ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆID**: `basic_monthly`
- **åå‰**: ã‚¬ãƒãƒˆãƒ¬ ãƒ™ãƒ¼ã‚·ãƒƒã‚¯ãƒ—ãƒ©ãƒ³
- **èª¬æ˜**: ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã«SNS URLã‚’è¡¨ç¤ºã€ä»–ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®é£Ÿäº‹ãƒ¡ãƒ‹ãƒ¥ãƒ¼é–²è¦§
- **ä¾¡æ ¼**: Â¥1,000
- **è«‹æ±‚æœŸé–“**: 1ãƒ¶æœˆ
- **ç„¡æ–™ãƒˆãƒ©ã‚¤ã‚¢ãƒ«**: ãªã—ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
- **ç‰¹å…¸æœŸé–“**: ãªã—

#### ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ãƒ—ãƒ©ãƒ³
- **ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆID**: `premium_monthly`
- **åå‰**: ã‚¬ãƒãƒˆãƒ¬ ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ãƒ—ãƒ©ãƒ³
- **èª¬æ˜**: ãƒ™ãƒ¼ã‚·ãƒƒã‚¯æ©Ÿèƒ½ + ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ç¢ºèª + ãƒ–ãƒ­ãƒƒã‚¯æ©Ÿèƒ½
- **ä¾¡æ ¼**: Â¥3,000
- **è«‹æ±‚æœŸé–“**: 1ãƒ¶æœˆ
- **ç„¡æ–™ãƒˆãƒ©ã‚¤ã‚¢ãƒ«**: ãªã—ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
- **ç‰¹å…¸æœŸé–“**: ãªã—

### 3. ãƒ†ã‚¹ã‚¿ãƒ¼è¨­å®š

1. **ãƒ†ã‚¹ãƒˆã®è¨­å®š â†’ ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ**
2. ãƒ†ã‚¹ã‚¿ãƒ¼ã®Googleã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’è¿½åŠ 
3. ãƒ†ã‚¹ãƒˆç”¨å¿œç­”ã‚’ã€Œè³¼å…¥æ¸ˆã¿ã€ã«è¨­å®š

---

## ãƒ†ã‚¹ãƒˆæ‰‹é †

### 1. ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹ãƒ†ã‚¹ãƒˆ

```bash
# ãƒ†ã‚¹ãƒˆç”¨ãƒ“ãƒ«ãƒ‰
flutter build appbundle --release

# ãƒ†ã‚¹ã‚¿ãƒ¼ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã§Google Playã‹ã‚‰ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
# ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³è³¼å…¥ã‚’ãƒ†ã‚¹ãƒˆ
```

### 2. ãƒ†ã‚¹ãƒˆã‚·ãƒŠãƒªã‚ª

#### âœ… è³¼å…¥ãƒ•ãƒ­ãƒ¼
1. ã‚¢ãƒ—ãƒªèµ·å‹• â†’ è¨­å®š â†’ ãƒ—ãƒ©ãƒ³å¤‰æ›´
2. ãƒ™ãƒ¼ã‚·ãƒƒã‚¯ãƒ—ãƒ©ãƒ³ã‚’é¸æŠ
3. Google Playè³¼å…¥ç”»é¢ã§ãƒ†ã‚¹ãƒˆè³¼å…¥
4. è³¼å…¥å®Œäº†å¾Œã€ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ç·¨é›†ã§SNSãƒªãƒ³ã‚¯è¿½åŠ å¯èƒ½ã‹ç¢ºèª

#### âœ… æ©Ÿèƒ½åˆ¶é™
1. ç„¡æ–™ãƒ—ãƒ©ãƒ³ã§SNSãƒªãƒ³ã‚¯ç·¨é›†ã‚’è©¦ã™ â†’ ã‚¨ãƒ©ãƒ¼è¡¨ç¤º
2. ç„¡æ–™ãƒ—ãƒ©ãƒ³ã§ä»–ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®é£Ÿäº‹é–²è¦§ â†’ ãƒ—ãƒ¬ãƒŸã‚¢ãƒ èª˜å°
3. ãƒ™ãƒ¼ã‚·ãƒƒã‚¯ãƒ—ãƒ©ãƒ³ã§ãƒ–ãƒ­ãƒƒã‚¯æ©Ÿèƒ½ â†’ ã‚¨ãƒ©ãƒ¼è¡¨ç¤º

#### âœ… å¾©å…ƒ
1. ã‚¢ãƒ—ãƒªã‚’ã‚¢ãƒ³ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
2. å†ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
3. ã€Œè³¼å…¥ã‚’å¾©å…ƒã€ã‚’ã‚¿ãƒƒãƒ—
4. ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãŒå¾©å…ƒã•ã‚Œã‚‹ã‹ç¢ºèª

#### âœ… æœ‰åŠ¹æœŸé™
1. ãƒ†ã‚¹ãƒˆç”¨ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ã®æœ‰åŠ¹æœŸé™ï¼ˆ5åˆ†ãªã©ï¼‰ã‚’å¾…ã¤
2. æœŸé™åˆ‡ã‚Œå¾Œã€ãƒ—ãƒ¬ãƒŸã‚¢ãƒ æ©Ÿèƒ½ãŒä½¿ãˆãªããªã‚‹ã‹ç¢ºèª

---

## ãƒªãƒªãƒ¼ã‚¹æ‰‹é †

### 1. ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãƒ‡ãƒ—ãƒ­ã‚¤

```bash
# Rust APIã‚’ãƒ‡ãƒ—ãƒ­ã‚¤
cd services/api_rust
fly deploy
```

### 2. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

```bash
# Supabaseã§ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
cd supabase
supabase db push
```

### 3. ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒ“ãƒ«ãƒ‰

```bash
cd apps/mobile_flutter
flutter clean
flutter pub get
flutter build appbundle --release
```

### 4. Google Play Consoleã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰

1. ç”Ÿæˆã•ã‚ŒãŸAABã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
2. ãƒªãƒªãƒ¼ã‚¹ãƒãƒ¼ãƒˆã«èª²é‡‘æ©Ÿèƒ½è¿½åŠ ã‚’è¨˜è¼‰
3. æ®µéšçš„å…¬é–‹ï¼ˆ10% â†’ 50% â†’ 100%ï¼‰

### 5. ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°

- Google Play Console â†’ åç›Šãƒ¬ãƒãƒ¼ãƒˆ
- Supabase â†’ user_subscriptionsãƒ†ãƒ¼ãƒ–ãƒ«
- ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ç›£è¦–ï¼ˆSentryç­‰ï¼‰

---

## ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è€ƒæ…®äº‹é …

### âœ… å®Ÿè£…æ¸ˆã¿
- JWTèªè¨¼ã«ã‚ˆã‚‹APIä¿è­·
- RLSã«ã‚ˆã‚‹ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡
- ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³æ¤œè¨¼ï¼ˆã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ï¼‰

### âš ï¸ è¿½åŠ æ¨å¥¨
- Google Play Billing APIæ¤œè¨¼ã®å®Ÿè£…
- è³¼å…¥ãƒˆãƒ¼ã‚¯ãƒ³ã®ç½²åæ¤œè¨¼
- ãƒ¬ãƒ¼ãƒˆåˆ¶é™ï¼ˆè³¼å…¥æ¤œè¨¼APIï¼‰
- ä¸æ­£è³¼å…¥ã®æ¤œå‡ºã¨ãƒ–ãƒ­ãƒƒã‚¯

---

## ä»Šå¾Œã®æ‹¡å¼µ

### Phase 2æ©Ÿèƒ½
- å¹´é–“ãƒ—ãƒ©ãƒ³ï¼ˆ20%å‰²å¼•ï¼‰
- ç„¡æ–™ãƒˆãƒ©ã‚¤ã‚¢ãƒ«ï¼ˆ7æ—¥é–“ï¼‰
- ç´¹ä»‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ 
- ã‚®ãƒ•ãƒˆã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³

### Phase 3æ©Ÿèƒ½
- ä¼æ¥­å‘ã‘ãƒ—ãƒ©ãƒ³
- ãƒˆãƒ¬ãƒ¼ãƒŠãƒ¼èªè¨¼ãƒ—ãƒ©ãƒ³
- ã‚³ãƒ³ãƒ†ãƒ³ãƒ„è²©å£²ï¼ˆè²·ã„åˆ‡ã‚Šï¼‰

---

## FAQ

### Q: è³¼å…¥ãŒã†ã¾ãã„ã‹ãªã„
A:
1. Google Playã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢
2. ã‚¢ãƒ—ãƒªã®å†èµ·å‹•
3. ã€Œè³¼å…¥ã‚’å¾©å…ƒã€ã‚’è©¦ã™
4. ãƒ†ã‚¹ã‚¿ãƒ¼ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã§æ­£ã—ããƒ­ã‚°ã‚¤ãƒ³ã—ã¦ã„ã‚‹ã‹ç¢ºèª

### Q: ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã§ããªã„
A: Google Playã®ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ç®¡ç†ã‹ã‚‰ç›´æ¥ã‚­ãƒ£ãƒ³ã‚»ãƒ«å¯èƒ½

### Q: æœ‰åŠ¹æœŸé™ãŒåˆ‡ã‚ŒãŸã®ã«æ©Ÿèƒ½ãŒä½¿ãˆã‚‹
A:
1. ã‚¢ãƒ—ãƒªã‚’å†èµ·å‹•
2. ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®cron jobã§æœŸé™åˆ‡ã‚Œãƒã‚§ãƒƒã‚¯ãŒå¿…è¦

---

## å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

### ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
- [ ] user_subscriptions ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆ
- [ ] user_profiles ã« subscription_tier è¿½åŠ 
- [ ] user_blocks ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆ
- [ ] RLSãƒãƒªã‚·ãƒ¼è¨­å®š
- [ ] ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆ

### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰
- [ ] ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³æ¤œè¨¼API
- [ ] è³¼å…¥æ¤œè¨¼ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
- [ ] ãƒ–ãƒ­ãƒƒã‚¯æ©Ÿèƒ½API
- [ ] SNSãƒªãƒ³ã‚¯æ›´æ–°API

### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰
- [ ] in_app_purchase çµ±åˆ
- [ ] ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³ç”»é¢
- [ ] è³¼å…¥ãƒ•ãƒ­ãƒ¼å®Ÿè£…
- [ ] ãƒ—ãƒ¬ãƒŸã‚¢ãƒ æ©Ÿèƒ½ã®UIåˆ¶å¾¡
- [ ] SNSãƒªãƒ³ã‚¯ç·¨é›†ç”»é¢
- [ ] ãƒ–ãƒ­ãƒƒã‚¯æ©Ÿèƒ½UI

### Google Play
- [ ] ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³å•†å“ä½œæˆ
- [ ] ãƒ†ã‚¹ã‚¿ãƒ¼ã‚¢ã‚«ã‚¦ãƒ³ãƒˆè¨­å®š
- [ ] ä¾¡æ ¼è¨­å®š

### ãƒ†ã‚¹ãƒˆ
- [ ] ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹ãƒ†ã‚¹ãƒˆ
- [ ] è³¼å…¥ãƒ•ãƒ­ãƒ¼
- [ ] å¾©å…ƒæ©Ÿèƒ½
- [ ] æ©Ÿèƒ½åˆ¶é™

### ãƒªãƒªãƒ¼ã‚¹
- [ ] æœ¬ç•ªç’°å¢ƒãƒ‡ãƒ—ãƒ­ã‚¤
- [ ] ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆä½œæˆ
- [ ] ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°è¨­å®š
- [ ] Google Playå…¬é–‹

---

## å‚è€ƒãƒªãƒ³ã‚¯

- [Flutter In-App Purchase](https://pub.dev/packages/in_app_purchase)
- [Google Play Billing](https://developer.android.com/google/play/billing)
- [Supabase RLS](https://supabase.com/docs/guides/auth/row-level-security)
- [RevenueCat](https://www.revenuecat.com/) (ã‚ªãƒ—ã‚·ãƒ§ãƒ³)
